\documentclass[a4paper]{article}
\usepackage[14pt]{extsizes} % для того чтобы задать нестандартный 14-ый размер шрифта
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{setspace,amsmath}
\usepackage[left=20mm, top=15mm, right=15mm, bottom=15mm, nohead, footskip=10mm]{geometry} % настройки полей документа

\begin{document} % начало документа
	
	% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
	\begin{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill\break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		{\LARGE Отчёт} \\
		\hfill \break
		А.А.Федяшов, Д.Е.Теплюков\\
		\hfill \break
		11.07.2017\\
		\hfill \break
		\hfill \break
	\end{center}
	
	
	\thispagestyle{empty} % выключаем отображение номера для этой страницы
	
	% КОНЕЦ ТИТУЛЬНОГО ЛИСТА
\newpage

% Вывод содержания проекта
\newpage
	{\section{Постановка задачи}
	\hfill\break
	{\bf 
	1.Написать класс двусвязный список с внешним итератором\\}
	Класс должен содержать:\\
	1)добавление элемента в начало, конец списка;\\
	2)удаление элемента из начала, конца списка;\\
	3)подсчёт количества элементов в списке;\\
	4)проверка списка на пустоту;\\
	5)получение итератора начала, конца списка;\\
	6)вставка значения до, после итератора;\\
	7)удаление значения по итератору;\\
	8)поиск значения в списке и получения итератора с указанным значением;\\
	9)ввод/вывод в поток.\\
	2.{\bf Используя двусвязный список целых чисел решить задачу:}\\
	Пользователем вводится последовательность элементов, признак окончания последовательности – не число (некорректный ввод). Реализовать хранение чисел в 
	списке в отсортированном виде, без повторяющихся значений. По окончании ввода вывести значения в порядке возрастания.\\
	3.{\bf Реализовать QtTest для класса список и класса итератор.}\\
}
        
          
\newpage
{\section{Содержание проекта}
        \hfill\break
        \hfill\break
{\bf 1)Заголовочные файлы(.h)}\\
        \hfill\break
        \textit{dlist.h}-содержит объявление методов класса DList и DIterator\\        
        \hfill\break
        \textit{qtest1.h}-содержит объявление функций тестирования классов DList и DIterator\\
        \hfill\break
        \textit{utility.h}-содержит объявление функции решения поставленной задачи для класса DList\\
        \hfill\break
        \hfill\break
{\bf 2)Файлы реализации(.cpp)}\\
        \hfill\break
        \textit{main.cpp}-главный файл проекта, содержит вызов тестов из заголовочного файла qtest1.h и вызов программы из заголовочного файла  utility.h. Также в файле реализован цикл для многократного ввода значений для программы из файла utility.h, что позволяет тестировать программу столько раз, сколько необходимо пользователю\\
        \hfill\break     
        \textit{dlist.cpp}-содержит реализацию методов из заголовочного файла dlist.h для классов DList и DIterator\\        
        \hfill\break
        \textit{qtest1.cpp}-содержит реализацию функций тестирования из заголовочного файла qtest1.h для классов DList и DIterator\\
        \hfill\break
        \textit{utility.cpp}-содержит реализацию функции решения поставленной задачи из заголовочного файла utility.h для класса DList\\
}
	
	\newpage %Аннотация
	
	\newpage %Введение
	
	\newpage %Результаты 
	{\section{Описание классов DList И DIterator}
	%Класс список	
	{\LARGE \bf DList}\\
	\hfill\break
	Класс список в представленном коде имеет название DList, содержит вложенный класс DIterator.\\
	\hfill\break
	{\bf Следующие конструкторы и методы имеют права доступа public}:\\
	\hfill \break
	1){\bf Конструктор по умолчанию, возвращает пустой список:}\\
	     \hfill \break
	     \textit{DList()}\\
	     \hfill \break
	     \hfill \break
	2){\bf Конструктор копии:}\\
	     \hfill \break
	     \textit{DList(const DList \&l)}\\
	     \hfill \break
	     \hfill \break
	3){\bf Конструктор, реализованный посредством объекта initializer\_list<int>,\\
		- список инициализации контейнера}\\
         \hfill \break	
	     \textit{DList(const std::initializer\_list<int> \& list)}\\
	     \hfill\break
	     {\bf Пример:}\\
	     \hfill \break
	     \textit{DList mc=\{1,2,3,4\}}\\
	     \hfill \break
	     \hfill \break
	Класс DList содержит перегрузки следующих операторов: присваивания(=), сравнения на равенство(==) и вывода(<<).\\
	Также этот класс имеет следующий перечень методов:\\
	     \hfill \break
	1){\bf Добавление элемента в конец списка:}\\
	     \hfill \break
	     \textit{void push\_back(const int \&x)}\\
	     \hfill \break
	     \hfill \break
	2){\bf Добавление элемента в начало списка:}\\
	     \hfill \break
	     \textit{void push\_front(const int \&x)}\\
	     \hfill \break
	     \hfill \break
	3){\bf Удаление первого элемента списка списка:}\\
	     \hfill \break
	     \textit{void pop\_front()}\\
	     \hfill \break
	     \hfill \break
	  В случае, когда список пустой, удаление не происходит, т.е список остается в неизменном состоянии\\
	     \hfill \break
	4){\bf Удаление последнего элемента списка:}\\
	     \hfill \break
	     \textit{void pop\_back()}\\
	     \hfill \break
	     \hfill \break
	  В случае, когда список пустой, удаление не происходит, т.е список остается в неизменном состоянии\\  
	  \hfill \break
	  \hfill \break
	5){\bf Возвращение значения первого элемента списка}\\
	     \hfill \break
	     \textit{int front() const}\\
	     \hfill \break
	     \hfill \break
	  Возвращаемое значение типа int\\    
	     \hfill \break
	     \hfill \break
	6){\bf Возвращение значения последнего элемента списка}\\
	    \hfill \break
	    \textit{int back() const}\\
	    \hfill \break
	    \hfill \break
	Возвращаемое значение типа int\\    
     	\hfill \break
	    \hfill \break
	7){\bf Очистка содержимого списка:}\\
	    \hfill \break
	    \textit{void erase()}\\        
	    \hfill \break
	    \hfill \break
	В результате работы функции получается пустой список\\
	    \hfill \break
	    \hfill \break    
	8){\bf Проверка на пустоту}\\
	    \hfill \break
	    \textit{bool is\_empty() const}\\
	    \hfill \break
	    \hfill \break
	Если список пуст, то возвращается значение true, иначе false\\ 
	    \hfill \break
	    \hfill \break 
	9){\bf Нахождение размера списка}\\
	    \hfill \break
	    \textit{size\_t size() const}\\
	    \hfill \break
	    \hfill \break 
	В поле private списка DList содержится структура node, которая хранит в себе основные поля списка\\
	    \hfill \break
	    \textit{int data} - значение элемента списка\\
	    \textit{node *prev} - ссылку на предыдущий элемент списка\\        
	    \textit{node *next} - ссылку на следующий элемент списка\\
        \hfill\break
    Также с правами доступа private\\
        \hfill\break
        \textit{node *first} - указатель на первый элемент списка\\
        \textit{node *last} - указатель на последний элемент списка\\
        \hfill\break
    и 2 функции\\
        \hfill\break
        \textit{void copy\_DList(const node *from\_first, const node *from\_last)}-копирования содержимого списка в другой список\\
        \textit{void delete\_DList()}-удаления списка\\
    \newpage%Класс итератор
    {\LARGE \bf Класс DIterator }\\
        \hfill\break
    {\bf Следующие конструкторы и методы имеют права доступа public}\\
        \hfill\break
    {\bf Конструктор с параметрами, где первый - указатель на голову списка, а второй - указатель на текущий элемент списка:}\\
        \hfill \break
        \textit{DIterator(DList *collection, node *current)}\\
        \hfill\break
        \hfill\break
    Класс DIterator содержит перегрузки следующих операторов: инкремент (префиксный/постфиксный)(++), декремент (префиксный/постфиксный)(--), разыменование(*), сравнение на равенство(==), неравенство(!=), больше(>) и меньше(<)\\
    Также этот класс имеет следующий перечень методов:\\
        \hfill\break
    1){\bf Возвращение итератора на начало списка:}\\
        \hfill\break
        \textit{DIterator begin()}\\
        \hfill\break
        \hfill\break
    2){\bf Возвращение итератора на конец списка:}\\
        \hfill\break
        \textit{DIterator end()}\\
        \hfill\break
        \hfill\break
    3){\bf Поиск элемента с заданным значением:}\\
        \hfill\break
        \textit{DIterator find(const int \&x)}\\
        \hfill\break
    Входное значение типа int, функция возвращает итератор на искомый элемент\\
        \hfill\break
        \hfill\break
    4){\bf Поиск первого элемента больше заданного:}\\
        \hfill\break
        \textit{DIterator findFEGG(const int \&x)}\\
        \hfill\break
    Входное значение типа int, функция возвращает итератор на искомый элемент\\
        \hfill\break
    Этой функции уделим отдельное внимание потому, что она занимает одну из ключевых ролей в работе программы по предложенной задаче.
    Сначала в функции идет проверка на кол-во элементов списка:\\
        \textit{if (this->size()>1)}\\
        \hfill\break
    Эта проверка имеет смысл. Если кол-во элементов меньше или ровно 1, то не стоит выполнять достаточно большой блок действий, который содержится внутри true ветки if. Для обработки этой ситуации достаточно такой проверки:\\
        \hfill\break
        \textit{if (DList\_DIterator.current->data>x)}\\
        \hfill\break                
    Если условие верно, то возвращаем указатель на наш единственный элемент списка.\\
        \hfill\break
    Если кол-во элементов списка > 1, то осуществляется поиск такого элемента, который больше заданного и элемент перед ним меньше заданного. Такое условие поиска гарантирует нам, что мы не нарушим формирующуюся возрастающую последовательность в программе для задачи.\\
    После нахождения первого такого элемента, мы возвращаем на него итератор.\\
        \hfill\break
    Хочется отметить, что эта функция специально писалась для предложенной задачи, и ряд решений в этой функции адаптирован специально для того, чтобы не испортить правильно формирующуюся последовательность в программе для задачи.\\ 
        \hfill\break
        \hfill\break
    5){\bf Вставка элемента, после элемента на который указывает итератор:}\\                                       
        \hfill\break
        \textit{void insert\_after(const DIterator \&it, const int \&x)}\\
        \hfill\break
    Входные значения: итератор на элемент const DIterator \&it, после которого нужно вставить const int \&x\\
        \hfill\break
        \hfill\break
    6){\bf Вставка элемента, до элемента на который указывает итератор:}\\                                       
        \hfill\break
        \textit{void insert\_before(const DIterator \&it, const int \&x)}\\
        \hfill\break
    Входные значения: итератор на элемент const DIterator \&it, до которого нужно вставить const int \&x\\
        \hfill\break
        \hfill\break
    7){\bf Удаление элемента, на который указывает итератор:}\\                                       
        \hfill\break
        \textit{void remove(const DIterator \&it)}\\
        \hfill\break
    Входные значения: указатель на элемент, который нужно удалить\\
                                 
    }
    {\section{Тестирование классов}
    {\LARGE \bf Класс Test\_DList(тестирующий класс)}\\
        \hfill\break
    При создании класса использовалась библиотека <QObject>\\
    Класс Test\_DList создан посредством наследования от исходного класса QObject\\
        \hfill\break
    В поле private этого класса хранятся функции тестирования методов классов DList и DIterator\\
    Также используются некоторые специфические методы тестирования из QTest, такие как:\\
        \hfill\break    
        \textit{void initTestCase()}-функция первичной инициализации, которая выполняет некоторую последовательность действий перед запуском тестов\\
        \hfill\break
        \textit{void cleanupTestCase()}-функция, которая выполняет некоторую последовательность действий после выполнения тестов\\
        \hfill\break
    Функции initTestCase() и cleanupTestCase() использованы для более корректного и наглядного вывода информации о ходе тестирования\\
        \hfill\break
    {\bf Пример теста}\\
        \hfill\break
    Пример теста будет показан на примере метода push\_back()\\
        \hfill\break
        \hfill\break
        \textit{
            void Test\_DList::push\_back()\\
            \{\\
        	  DList mc=\{1,2,3,4\};\\
        	  DList expected=\{1,2,3,4,5\};\\
        	  mc.push\_back(5);\\
        	  QVERIFY(mc==expected);\\
            \}\\
        }
        \hfill\break
   Объявляем исходный список mc, и ожидаемый expected.\\
   Вызываем метод push\_back() для класса mc\\
   В функции QVERIFY происходит сравнение модифицированного списка и ожидаемого. В случае если в результате сравнения вернется true, то тест выдаст сообщение Pass!, означающие, что тест пройден успешно, иначе, если вернется значение false, то в терминал будет выведено сообщение об ошибке. Есть возможность конкретизировать ошибку и воспользоваться функцией QVERIFY2, которая в качестве 2 параметра принимает текстовое сообщение об ошибке.\\      
           
    }  
    {\section{Особенности реализации программы}
    Для начала необходимо было перехватить поток терминала, для этого выполнили следующее действие:\\
       \hfill\break
       \textit{QTextStream IN(stdin)}\\
       \hfill\break
    Обработали условие, что если сразу получаем символ конца строки '.', то список не формируется.\\
    Повторений одинаковых элементов избегаем с помощью проверки следующего условия:\\
       \hfill\break
       \textit{if (list1.find(b.toInt())==list1.end())}\\
       \hfill\break 
    Ключевым моментом программы является то, что мы ищем текущий максимум в списке.\\
    Если нововходящий элемент больше максимума, то, очевидно, этот элемент нужно добавить в конец, иначе его нужно вставить перед первым элементом больше него. Осуществляется это следующим образом:\\
       \hfill\break
       \textit{list1.insert\_before(list1.findFEGG(b.toInt()),b.toInt())}\\
       \hfill\break
    В конце программы выводим уже отсортированный список.    
            
    }   	            
\end{document}